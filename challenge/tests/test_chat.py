
# Generated by Qodo Gen

from main import Chatbot
import openai

class TestChatbot:

    # Chatbot correctly detects input language using OpenAI API
    def test_detect_language_english(self, mocker):
        # Arrange
        chatbot = Chatbot()
        mock_response = mocker.Mock()
        mock_response.choices = [mocker.Mock()]
        mock_response.choices[0].message = {'content': 'English'}
        mocker.patch('openai.ChatCompletion.create', return_value=mock_response)

        # Act
        detected_language = chatbot.detect_language("Hello, how are you?")

        # Assert
        assert detected_language == "english"
        openai.ChatCompletion.create.assert_called_once()

    # Handle empty or whitespace-only user input
    def test_detect_language_empty_input(self, mocker):
        # Arrange
        chatbot = Chatbot()
        mock_response = mocker.Mock()
        mock_response.choices = [mocker.Mock()]
        mock_response.choices[0].message = {'content': 'Unknown'}
        mocker.patch('openai.ChatCompletion.create', return_value=mock_response)

        # Act
        detected_language = chatbot.detect_language("   ")

        # Assert
        assert detected_language == "unknown"
        openai.ChatCompletion.create.assert_called_once()

    # Chatbot performs web search and extracts relevant content
    def test_generate_response_with_search(self, mocker):
      # Arrange
      chatbot = Chatbot()
      mock_search_results = [
          {'title': 'Result 1', 'link': 'http://example.com/1', 'snippet': 'Snippet 1'},
          {'title': 'Result 2', 'link': 'http://example.com/2', 'snippet': 'Snippet 2'}
      ]
      mock_page_content = "This is the page content."

      # Mock for language detection
      mock_language_response = mocker.Mock()
      mock_language_response.choices = [mocker.Mock()]
      mock_language_response.choices[0].message = {'content': 'english'}

      # Mock for chat completion - make it iterable
      mock_chunk = mocker.Mock()
      mock_chunk.choices = [mocker.Mock()]
      mock_chunk.choices[0].delta = mocker.Mock(content="This is a response.")
      mock_chat_response = [mock_chunk]  # List of chunks to make it iterable

      # Setup the mocks
      mocker.patch('openai.ChatCompletion.create', side_effect=[
          mock_language_response,  # First call for language detection
          mock_chat_response      # Second call for response generation
      ])
      mocker.patch.object(chatbot.search_engine, 'search', return_value=mock_search_results)
      mocker.patch.object(chatbot.search_engine, 'get_page_content', return_value=mock_page_content)

      # Act
      chatbot.generate_response("What is AI?")

    # Conversation history is properly maintained in memory
    def test_conversation_history_maintenance(self, mocker):
      # Arrange
      chatbot = Chatbot()
      mock_search = mocker.patch.object(chatbot.search_engine, 'search', return_value=[])
      mock_get_page_content = mocker.patch.object(chatbot.search_engine, 'get_page_content', return_value="")

      # Mock for language detection
      mock_language_response = mocker.Mock()
      mock_language_response.choices = [mocker.Mock()]
      mock_language_response.choices[0].message = {'content': 'english'}

      # Mock for chat completion
      mock_chat_response = mocker.Mock()
      mock_chat_response.choices = [mocker.Mock()]
      mock_chat_response.choices[0].delta = mocker.Mock(content="This is a response.")

      # Setup the mocks with side_effect to handle multiple calls
      mocker.patch('openai.ChatCompletion.create', side_effect=[
          mock_language_response,  # First call for language detection
          [mock_chat_response]    # Second call for response generation (as list for iteration)
      ])

      # Act
      chatbot.generate_response("Hello, how are you?")

    # Streaming response is properly chunked and displayed
    def test_generate_response_streaming(self, mocker):
      # Arrange
      chatbot = Chatbot()
      user_input = "What is the capital of France?"
      
      # Define mock search results first
      mock_search_results = [
          {'title': 'Paris - Wikipedia', 
          'link': 'https://en.wikipedia.org/wiki/Paris', 
          'snippet': 'Paris is the capital city of France.'}
      ]
      mock_page_content = "Paris is the capital and most populous city of France."
      
      # Mock para detecci√≥n de idioma
      mock_language_response = mocker.Mock()
      mock_language_response.choices = [mocker.Mock()]
      mock_language_response.choices[0].message = {'content': 'english'}
      
      # Mock para respuesta en streaming
      mock_response_chunks = [
          mocker.Mock(choices=[mocker.Mock(delta=mocker.Mock(content='The capital of France is '))]),
          mocker.Mock(choices=[mocker.Mock(delta=mocker.Mock(content='Paris.'))])
      ]
      
      # Configurar los mocks en orden correcto
      mocker.patch('openai.ChatCompletion.create', side_effect=[
          mock_language_response,
          mock_response_chunks
      ])
      mocker.patch.object(chatbot.search_engine, 'search', return_value=mock_search_results)
      mocker.patch.object(chatbot.search_engine, 'get_page_content', return_value=mock_page_content)
      
      # Act
      chatbot.generate_response(user_input)

    # Sources are correctly formatted and displayed
    def test_generate_response_sources_format(self, mocker):
      # Arrange
      chatbot = Chatbot()
      mock_search_results = [
          {'title': 'Test Title 1', 'link': 'http://example.com/1', 'snippet': 'Snippet 1'},
          {'title': 'Test Title 2', 'link': 'http://example.com/2', 'snippet': 'Snippet 2'}
      ]
      
      # Mock for language detection
      mock_language_response = mocker.Mock()
      mock_language_response.choices = [mocker.Mock()]
      mock_language_response.choices[0].message = {'content': 'english'}
      
      # Mock for chat completion
      mock_chat_response = mocker.Mock()
      mock_chat_response.choices = [mocker.Mock()]
      mock_chat_response.choices[0].delta = mocker.Mock(content='Response content')
      
      # Setup mocks with correct side effects
      mocker.patch('openai.ChatCompletion.create', side_effect=[
          mock_language_response,  # For language detection
          [mock_chat_response]    # For streaming response
      ])
      mocker.patch.object(chatbot.search_engine, 'search', return_value=mock_search_results)
      mocker.patch.object(chatbot.search_engine, 'get_page_content', return_value='Page content')
      
      # Act
      mock_print = mocker.patch('builtins.print')
      chatbot.generate_response("Test input")
      
      # Assert
      expected_sources = [
          "- [Test Title 1](http://example.com/1)",
          "- [Test Title 2](http://example.com/2)"
      ]
      for source in expected_sources:
          mock_print.assert_any_call(source)
